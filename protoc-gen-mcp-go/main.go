package main

import (
	"text/template"

	"github.com/mark3labs/mcp-go/mcp"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{
		ParamFunc: func(name, value string) error {
			return nil
		},
	}.Run(generate)
}

func generate(gen *protogen.Plugin) error {
	for _, f := range gen.Files {
		if !f.Generate {
			continue
		}
		newFileGenerator(f, gen).Generate()
	}
	return nil
}

type fileGenerator struct {
	f   *protogen.File
	gen *protogen.Plugin

	allConsts map[string]struct{}
	gf        *protogen.GeneratedFile
}

func newFileGenerator(f *protogen.File, gen *protogen.Plugin) *fileGenerator {
	gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

	return &fileGenerator{f: f, gen: gen}
}

const fileTemplate = `// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: {{ .SourcePath }}

package {{ .GoPackage }}

import (
	"context"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"encoding/json"
	"google.golang.org/protobuf/encoding/protojson"
)

var (
{{- range $key, $val := .Tools }}
	{{$key}}Tool = {{ printf "%#v" $val }}
{{- end }}
)

{{- range $key, $val := .Services }}
func Register{{$key}}MCP(s *mcpserver.MCPServer, srv {{$key}}Server) {
  {{- range $tool_name, $tool_val := $val }}
  s.AddTool({{$tool_name}}Tool,func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req {{$tool_val.RequestType}}
		if err := protojson.Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.{{$tool_name}}(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = protojson.Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
  })
  {{- end }}
}
{{- end }}
`

type tplParams struct {
	PackageName string
	SourcePath  string
	GoPackage   string
	Tools       map[string]mcp.Tool
	Services    map[string]map[string]Tool
}

type Tool struct {
	RequestType  string
	ResponseType string
	MCPTool      mcp.Tool
}

func getType(fd protoreflect.FieldDescriptor) map[string]any {

	switch fd.Kind() {
	case protoreflect.BoolKind:
		return map[string]any{
			"type": "boolean",
		}
	case protoreflect.EnumKind:
		var values []string

		for i := 0; i < fd.Enum().Values().Len(); i++ {
			ev := fd.Enum().Values().Get(i)
			values = append(values, string(ev.Name()))
		}
		return map[string]any{
			"type": "string",
			"enum": values,
		}
	case protoreflect.Int32Kind:
		fallthrough
	case protoreflect.Sint32Kind:
		fallthrough
	case protoreflect.Sfixed32Kind:
		fallthrough
	case protoreflect.Fixed32Kind:
		fallthrough
	case protoreflect.Uint32Kind:
		return map[string]any{
			"type": "number",
		}
	case protoreflect.Int64Kind:
		fallthrough
	case protoreflect.Sint64Kind:
		fallthrough
	case protoreflect.Sfixed64Kind:
		fallthrough
	case protoreflect.Fixed64Kind:
		fallthrough
	case protoreflect.Uint64Kind:
		return map[string]any{
			"type": "string",
		}
	case protoreflect.FloatKind:
		return map[string]any{
			"type": "number",
		}
	case protoreflect.DoubleKind:
		return map[string]any{
			"type": "string",
		}
	case protoreflect.StringKind:
		return map[string]any{
			"type": "string",
		}
	case protoreflect.BytesKind:
		return map[string]any{
			"type": "string",
		}
	case protoreflect.MessageKind:
		schema := map[string]any{}
		required := []string{}
		for i := 0; i < fd.Message().Fields().Len(); i++ {
			nestedFd := fd.Message().Fields().Get(i)
			name := string(nestedFd.Name())
			schema[name] = getType(nestedFd)
			if !nestedFd.HasOptionalKeyword() {
				required = append(required, name)
			}
		}

		// TODO handle map,repeated....
		return map[string]any{
			"type":       "object",
			"properties": schema,
			"required":   required,
		}

		// mcp.WithObject(name, mcp.Properties(x))

	case protoreflect.GroupKind:

	}
	return nil
}

func (g *fileGenerator) Generate() {
	g.gf = g.gen.NewGeneratedFile(g.f.GeneratedFilenamePrefix+".pb.mcp.go", g.f.GoImportPath)

	fileTpl := fileTemplate
	tpl, err := template.New("gen").Parse(fileTpl)
	if err != nil {
		g.gen.Error(err)
		return
	}

	// Gather data

	// TODO sanitize tool name

	services := map[string]map[string]Tool{}
	tools := map[string]mcp.Tool{}

	// Scan over services

	for _, svc := range g.f.Services {
		s := map[string]Tool{}
		for _, meth := range svc.Methods {
			tool := mcp.Tool{
				Name: string(meth.Desc.Name()),
				InputSchema: mcp.ToolInputSchema{
					Type:       "object",
					Properties: map[string]interface{}{},
					Required:   []string{},
				},
			}

			for _, field := range meth.Input.Fields {
				name := string(field.Desc.Name())
				if !field.Desc.HasOptionalKeyword() {
					tool.InputSchema.Required = append(tool.InputSchema.Required, name)
				}
				tool.InputSchema.Properties[name] = getType(field.Desc)
			}
			s[meth.GoName] = Tool{
				RequestType:  string(meth.Input.Desc.Name()),
				ResponseType: string(meth.Output.Desc.Name()),
				MCPTool:      tool,
			}
			tools[string(meth.Desc.Name())] = tool
		}
		services[string(svc.Desc.Name())] = s
	}

	params := tplParams{
		PackageName: string(g.f.Desc.Package()),
		SourcePath:  g.f.Desc.Path(),
		GoPackage:   string(g.f.GoPackageName),
		Services:    services,
		Tools:       tools,
	}
	err = tpl.Execute(g.gf, params)
	if err != nil {
		g.gen.Error(err)
	}
}
